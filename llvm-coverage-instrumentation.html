<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>LLVM Source-Based Code Coverage - Guide to Rustc Development</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A guide to developing rustc">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="about-this-guide.html">About this guide</a></li><li class="chapter-item affix "><a href="getting-started.html">Getting Started</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Building and debugging rustc</li><li class="chapter-item "><a href="building/how-to-build-and-run.html"><strong aria-hidden="true">1.</strong> How to Build and Run the Compiler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="building/prerequisites.html"><strong aria-hidden="true">1.1.</strong> Prerequisites</a></li><li class="chapter-item "><a href="building/suggested.html"><strong aria-hidden="true">1.2.</strong> Suggested Workflows</a></li><li class="chapter-item "><a href="building/build-install-distribution-artifacts.html"><strong aria-hidden="true">1.3.</strong> Distribution artifacts</a></li><li class="chapter-item "><a href="building/compiler-documenting.html"><strong aria-hidden="true">1.4.</strong> Building Documentation</a></li><li class="chapter-item "><a href="rustdoc.html"><strong aria-hidden="true">1.5.</strong> Rustdoc overview</a></li><li class="chapter-item "><a href="building/new-target.html"><strong aria-hidden="true">1.6.</strong> Adding a new target</a></li></ol></li><li class="chapter-item "><a href="tests/intro.html"><strong aria-hidden="true">2.</strong> Testing the compiler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tests/running.html"><strong aria-hidden="true">2.1.</strong> Running tests</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tests/docker.html"><strong aria-hidden="true">2.1.1.</strong> Testing with Docker</a></li><li class="chapter-item "><a href="tests/ci.html"><strong aria-hidden="true">2.1.2.</strong> Testing with CI</a></li></ol></li><li class="chapter-item "><a href="tests/adding.html"><strong aria-hidden="true">2.2.</strong> Adding new tests</a></li><li class="chapter-item "><a href="tests/compiletest.html"><strong aria-hidden="true">2.3.</strong> Compiletest</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tests/ui.html"><strong aria-hidden="true">2.3.1.</strong> UI tests</a></li><li class="chapter-item "><a href="tests/headers.html"><strong aria-hidden="true">2.3.2.</strong> Test headers</a></li></ol></li><li class="chapter-item "><a href="tests/perf.html"><strong aria-hidden="true">2.4.</strong> Performance testing</a></li><li class="chapter-item "><a href="tests/crater.html"><strong aria-hidden="true">2.5.</strong> Crater</a></li></ol></li><li class="chapter-item "><a href="compiler-debugging.html"><strong aria-hidden="true">3.</strong> Debugging the Compiler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tracing.html"><strong aria-hidden="true">3.1.</strong> Using the tracing/logging instrumentation</a></li></ol></li><li class="chapter-item "><a href="profiling.html"><strong aria-hidden="true">4.</strong> Profiling the compiler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="profiling/with_perf.html"><strong aria-hidden="true">4.1.</strong> with the linux perf tool</a></li><li class="chapter-item "><a href="profiling/wpa_profiling.html"><strong aria-hidden="true">4.2.</strong> with Windows Performance Analyzer</a></li></ol></li><li class="chapter-item "><a href="crates-io.html"><strong aria-hidden="true">5.</strong> crates.io Dependencies</a></li><li class="chapter-item affix "><li class="part-title">Contributing to Rust</li><li class="chapter-item "><a href="contributing.html"><strong aria-hidden="true">6.</strong> Introduction</a></li><li class="chapter-item "><a href="compiler-team.html"><strong aria-hidden="true">7.</strong> About the compiler team</a></li><li class="chapter-item "><a href="git.html"><strong aria-hidden="true">8.</strong> Using Git</a></li><li class="chapter-item "><a href="rustbot.html"><strong aria-hidden="true">9.</strong> Mastering @rustbot</a></li><li class="chapter-item "><a href="walkthrough.html"><strong aria-hidden="true">10.</strong> Walkthrough: a typical contribution</a></li><li class="chapter-item "><a href="bug-fix-procedure.html"><strong aria-hidden="true">11.</strong> Bug Fix Procedure</a></li><li class="chapter-item "><a href="implementing_new_features.html"><strong aria-hidden="true">12.</strong> Implementing new features</a></li><li class="chapter-item "><a href="stability.html"><strong aria-hidden="true">13.</strong> Stability attributes</a></li><li class="chapter-item "><a href="stabilization_guide.html"><strong aria-hidden="true">14.</strong> Stabilizing Features</a></li><li class="chapter-item "><a href="feature-gates.html"><strong aria-hidden="true">15.</strong> Feature Gates</a></li><li class="chapter-item "><a href="conventions.html"><strong aria-hidden="true">16.</strong> Coding conventions</a></li><li class="chapter-item "><a href="notification-groups/about.html"><strong aria-hidden="true">17.</strong> Notification groups</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="notification-groups/arm.html"><strong aria-hidden="true">17.1.</strong> ARM</a></li><li class="chapter-item "><a href="notification-groups/cleanup-crew.html"><strong aria-hidden="true">17.2.</strong> Cleanup Crew</a></li><li class="chapter-item "><a href="notification-groups/llvm.html"><strong aria-hidden="true">17.3.</strong> LLVM</a></li><li class="chapter-item "><a href="notification-groups/risc-v.html"><strong aria-hidden="true">17.4.</strong> RISC-V</a></li><li class="chapter-item "><a href="notification-groups/windows.html"><strong aria-hidden="true">17.5.</strong> Windows</a></li></ol></li><li class="chapter-item "><a href="licenses.html"><strong aria-hidden="true">18.</strong> Licenses</a></li><li class="chapter-item affix "><li class="part-title">High-level Compiler Architecture</li><li class="chapter-item "><a href="part-2-intro.html"><strong aria-hidden="true">19.</strong> Prologue</a></li><li class="chapter-item "><a href="overview.html"><strong aria-hidden="true">20.</strong> Overview of the Compiler</a></li><li class="chapter-item "><a href="compiler-src.html"><strong aria-hidden="true">21.</strong> The compiler source code</a></li><li class="chapter-item "><a href="building/bootstrapping.html"><strong aria-hidden="true">22.</strong> Bootstrapping</a></li><li class="chapter-item "><a href="query.html"><strong aria-hidden="true">23.</strong> Queries: demand-driven compilation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="queries/query-evaluation-model-in-detail.html"><strong aria-hidden="true">23.1.</strong> The Query Evaluation Model in Detail</a></li><li class="chapter-item "><a href="queries/incremental-compilation.html"><strong aria-hidden="true">23.2.</strong> Incremental compilation</a></li><li class="chapter-item "><a href="queries/incremental-compilation-in-detail.html"><strong aria-hidden="true">23.3.</strong> Incremental compilation In Detail</a></li><li class="chapter-item "><a href="incrcomp-debugging.html"><strong aria-hidden="true">23.4.</strong> Debugging and Testing</a></li><li class="chapter-item "><a href="salsa.html"><strong aria-hidden="true">23.5.</strong> Salsa</a></li></ol></li><li class="chapter-item "><a href="memory.html"><strong aria-hidden="true">24.</strong> Memory Management in Rustc</a></li><li class="chapter-item "><a href="serialization.html"><strong aria-hidden="true">25.</strong> Serialization in Rustc</a></li><li class="chapter-item "><a href="parallel-rustc.html"><strong aria-hidden="true">26.</strong> Parallel Compilation</a></li><li class="chapter-item "><a href="rustdoc-internals.html"><strong aria-hidden="true">27.</strong> Rustdoc internals</a></li><li class="chapter-item affix "><li class="part-title">Source Code Representation</li><li class="chapter-item "><a href="part-3-intro.html"><strong aria-hidden="true">28.</strong> Prologue</a></li><li class="chapter-item "><a href="cli.html"><strong aria-hidden="true">29.</strong> Command-line arguments</a></li><li class="chapter-item "><a href="rustc-driver.html"><strong aria-hidden="true">30.</strong> The Rustc Driver and Interface</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="rustc-driver-interacting-with-the-ast.html"><strong aria-hidden="true">30.1.</strong> Example: Type checking</a></li><li class="chapter-item "><a href="rustc-driver-getting-diagnostics.html"><strong aria-hidden="true">30.2.</strong> Example: Getting diagnostics</a></li></ol></li><li class="chapter-item "><a href="syntax-intro.html"><strong aria-hidden="true">31.</strong> Syntax and the AST</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="the-parser.html"><strong aria-hidden="true">31.1.</strong> Lexing and Parsing</a></li><li class="chapter-item "><a href="macro-expansion.html"><strong aria-hidden="true">31.2.</strong> Macro expansion</a></li><li class="chapter-item "><a href="name-resolution.html"><strong aria-hidden="true">31.3.</strong> Name resolution</a></li><li class="chapter-item "><a href="test-implementation.html"><strong aria-hidden="true">31.4.</strong> #[test] Implementation</a></li><li class="chapter-item "><a href="panic-implementation.html"><strong aria-hidden="true">31.5.</strong> Panic Implementation</a></li><li class="chapter-item "><a href="ast-validation.html"><strong aria-hidden="true">31.6.</strong> AST Validation</a></li><li class="chapter-item "><a href="feature-gate-ck.html"><strong aria-hidden="true">31.7.</strong> Feature Gate Checking</a></li><li class="chapter-item "><a href="lang-items.html"><strong aria-hidden="true">31.8.</strong> Lang Items</a></li></ol></li><li class="chapter-item "><a href="hir.html"><strong aria-hidden="true">32.</strong> The HIR (High-level IR)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lowering.html"><strong aria-hidden="true">32.1.</strong> Lowering AST to HIR</a></li><li class="chapter-item "><a href="hir-debugging.html"><strong aria-hidden="true">32.2.</strong> Debugging</a></li></ol></li><li class="chapter-item "><a href="thir.html"><strong aria-hidden="true">33.</strong> The THIR (Typed High-level IR)</a></li><li class="chapter-item "><a href="mir/index.html"><strong aria-hidden="true">34.</strong> The MIR (Mid-level IR)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="mir/construction.html"><strong aria-hidden="true">34.1.</strong> MIR construction</a></li><li class="chapter-item "><a href="mir/visitor.html"><strong aria-hidden="true">34.2.</strong> MIR visitor and traversal</a></li><li class="chapter-item "><a href="mir/passes.html"><strong aria-hidden="true">34.3.</strong> MIR passes: getting the MIR for a function</a></li></ol></li><li class="chapter-item "><a href="identifiers.html"><strong aria-hidden="true">35.</strong> Identifiers in the Compiler</a></li><li class="chapter-item "><a href="closure.html"><strong aria-hidden="true">36.</strong> Closure expansion</a></li><li class="chapter-item "><a href="asm.html"><strong aria-hidden="true">37.</strong> Inline assembly</a></li><li class="chapter-item affix "><li class="part-title">Analysis</li><li class="chapter-item "><a href="part-4-intro.html"><strong aria-hidden="true">38.</strong> Prologue</a></li><li class="chapter-item "><a href="ty.html"><strong aria-hidden="true">39.</strong> The ty module: representing types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics.html"><strong aria-hidden="true">39.1.</strong> Generics and substitutions</a></li><li class="chapter-item "><a href="ty-fold.html"><strong aria-hidden="true">39.2.</strong> TypeFolder and TypeFoldable</a></li><li class="chapter-item "><a href="generic_arguments.html"><strong aria-hidden="true">39.3.</strong> Generic arguments</a></li><li class="chapter-item "><a href="constants.html"><strong aria-hidden="true">39.4.</strong> Constants in the type system</a></li></ol></li><li class="chapter-item "><a href="type-inference.html"><strong aria-hidden="true">40.</strong> Type inference</a></li><li class="chapter-item "><a href="traits/resolution.html"><strong aria-hidden="true">41.</strong> Trait solving</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="early-late-bound.html"><strong aria-hidden="true">41.1.</strong> Early and Late Bound Parameters</a></li><li class="chapter-item "><a href="traits/hrtb.html"><strong aria-hidden="true">41.2.</strong> Higher-ranked trait bounds</a></li><li class="chapter-item "><a href="traits/caching.html"><strong aria-hidden="true">41.3.</strong> Caching subtleties</a></li><li class="chapter-item "><a href="traits/specialization.html"><strong aria-hidden="true">41.4.</strong> Specialization</a></li><li class="chapter-item "><a href="traits/chalk.html"><strong aria-hidden="true">41.5.</strong> Chalk-based trait solving</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="traits/lowering-to-logic.html"><strong aria-hidden="true">41.5.1.</strong> Lowering to logic</a></li><li class="chapter-item "><a href="traits/goals-and-clauses.html"><strong aria-hidden="true">41.5.2.</strong> Goals and clauses</a></li><li class="chapter-item "><a href="traits/canonical-queries.html"><strong aria-hidden="true">41.5.3.</strong> Canonical queries</a></li></ol></li><li class="chapter-item "><a href="solve/trait-solving.html"><strong aria-hidden="true">41.6.</strong> Next-gen trait solving</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="solve/the-solver.html"><strong aria-hidden="true">41.6.1.</strong> The solver</a></li><li class="chapter-item "><a href="solve/canonicalization.html"><strong aria-hidden="true">41.6.2.</strong> Canonicalization</a></li><li class="chapter-item "><a href="solve/coinduction.html"><strong aria-hidden="true">41.6.3.</strong> Coinduction</a></li></ol></li></ol></li><li class="chapter-item "><a href="type-checking.html"><strong aria-hidden="true">42.</strong> Type checking</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="method-lookup.html"><strong aria-hidden="true">42.1.</strong> Method Lookup</a></li><li class="chapter-item "><a href="variance.html"><strong aria-hidden="true">42.2.</strong> Variance</a></li><li class="chapter-item "><a href="opaque-types-type-alias-impl-trait.html"><strong aria-hidden="true">42.3.</strong> Opaque Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="opaque-types-impl-trait-inference.html"><strong aria-hidden="true">42.3.1.</strong> Inference details</a></li></ol></li></ol></li><li class="chapter-item "><a href="pat-exhaustive-checking.html"><strong aria-hidden="true">43.</strong> Pattern and Exhaustiveness Checking</a></li><li class="chapter-item "><a href="mir/dataflow.html"><strong aria-hidden="true">44.</strong> MIR dataflow</a></li><li class="chapter-item "><a href="mir/drop-elaboration.html"><strong aria-hidden="true">45.</strong> Drop elaboration</a></li><li class="chapter-item "><a href="borrow_check.html"><strong aria-hidden="true">46.</strong> The borrow checker</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="borrow_check/moves_and_initialization.html"><strong aria-hidden="true">46.1.</strong> Tracking moves and initialization</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="borrow_check/moves_and_initialization/move_paths.html"><strong aria-hidden="true">46.1.1.</strong> Move paths</a></li></ol></li><li class="chapter-item "><a href="borrow_check/type_check.html"><strong aria-hidden="true">46.2.</strong> MIR type checker</a></li><li class="chapter-item "><a href="borrow_check/region_inference.html"><strong aria-hidden="true">46.3.</strong> Region inference</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="borrow_check/region_inference/constraint_propagation.html"><strong aria-hidden="true">46.3.1.</strong> Constraint propagation</a></li><li class="chapter-item "><a href="borrow_check/region_inference/lifetime_parameters.html"><strong aria-hidden="true">46.3.2.</strong> Lifetime parameters</a></li><li class="chapter-item "><a href="borrow_check/region_inference/member_constraints.html"><strong aria-hidden="true">46.3.3.</strong> Member constraints</a></li><li class="chapter-item "><a href="borrow_check/region_inference/placeholders_and_universes.html"><strong aria-hidden="true">46.3.4.</strong> Placeholders and universes</a></li><li class="chapter-item "><a href="borrow_check/region_inference/closure_constraints.html"><strong aria-hidden="true">46.3.5.</strong> Closure constraints</a></li><li class="chapter-item "><a href="borrow_check/region_inference/error_reporting.html"><strong aria-hidden="true">46.3.6.</strong> Error reporting</a></li></ol></li><li class="chapter-item "><a href="borrow_check/two_phase_borrows.html"><strong aria-hidden="true">46.4.</strong> Two-phase-borrows</a></li></ol></li><li class="chapter-item "><a href="param_env.html"><strong aria-hidden="true">47.</strong> Parameter Environments</a></li><li class="chapter-item "><a href="diagnostics.html"><strong aria-hidden="true">48.</strong> Errors and Lints</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="diagnostics/diagnostic-structs.html"><strong aria-hidden="true">48.1.</strong> Diagnostic and subdiagnostic structs</a></li><li class="chapter-item "><a href="diagnostics/translation.html"><strong aria-hidden="true">48.2.</strong> Translation</a></li><li class="chapter-item "><a href="diagnostics/lintstore.html"><strong aria-hidden="true">48.3.</strong> LintStore</a></li><li class="chapter-item "><a href="diagnostics/diagnostic-codes.html"><strong aria-hidden="true">48.4.</strong> Diagnostic codes</a></li><li class="chapter-item "><a href="diagnostics/diagnostic-items.html"><strong aria-hidden="true">48.5.</strong> Diagnostic items</a></li><li class="chapter-item "><a href="diagnostics/error-guaranteed.html"><strong aria-hidden="true">48.6.</strong> ErrorGuaranteed</a></li></ol></li><li class="chapter-item "><li class="part-title">MIR to Binaries</li><li class="chapter-item "><a href="part-5-intro.html"><strong aria-hidden="true">49.</strong> Prologue</a></li><li class="chapter-item "><a href="mir/optimizations.html"><strong aria-hidden="true">50.</strong> MIR optimizations</a></li><li class="chapter-item "><a href="mir/debugging.html"><strong aria-hidden="true">51.</strong> Debugging</a></li><li class="chapter-item "><a href="const-eval.html"><strong aria-hidden="true">52.</strong> Constant evaluation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="const-eval/interpret.html"><strong aria-hidden="true">52.1.</strong> Interpreter</a></li></ol></li><li class="chapter-item "><a href="backend/monomorph.html"><strong aria-hidden="true">53.</strong> Monomorphization</a></li><li class="chapter-item "><a href="backend/lowering-mir.html"><strong aria-hidden="true">54.</strong> Lowering MIR</a></li><li class="chapter-item "><a href="backend/codegen.html"><strong aria-hidden="true">55.</strong> Code Generation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="backend/updating-llvm.html"><strong aria-hidden="true">55.1.</strong> Updating LLVM</a></li><li class="chapter-item "><a href="backend/debugging.html"><strong aria-hidden="true">55.2.</strong> Debugging LLVM</a></li><li class="chapter-item "><a href="backend/backend-agnostic.html"><strong aria-hidden="true">55.3.</strong> Backend Agnostic Codegen</a></li><li class="chapter-item "><a href="backend/implicit-caller-location.html"><strong aria-hidden="true">55.4.</strong> Implicit Caller Location</a></li></ol></li><li class="chapter-item "><a href="backend/libs-and-metadata.html"><strong aria-hidden="true">56.</strong> Libraries and Metadata</a></li><li class="chapter-item "><a href="profile-guided-optimization.html"><strong aria-hidden="true">57.</strong> Profile-guided Optimization</a></li><li class="chapter-item expanded "><a href="llvm-coverage-instrumentation.html" class="active"><strong aria-hidden="true">58.</strong> LLVM Source-Based Code Coverage</a></li><li class="chapter-item "><a href="sanitizers.html"><strong aria-hidden="true">59.</strong> Sanitizers Support</a></li><li class="chapter-item "><a href="debugging-support-in-rustc.html"><strong aria-hidden="true">60.</strong> Debugging Support in the Rust Compiler</a></li><li class="spacer"></li><li class="chapter-item affix "><a href="appendix/background.html">Appendix A: Background topics</a></li><li class="chapter-item affix "><a href="appendix/glossary.html">Appendix B: Glossary</a></li><li class="chapter-item affix "><a href="appendix/code-index.html">Appendix C: Code Index</a></li><li class="chapter-item affix "><a href="appendix/compiler-lecture.html">Appendix D: Compiler Lecture Series</a></li><li class="chapter-item affix "><a href="appendix/bibliography.html">Appendix E: Bibliography</a></li><li class="chapter-item affix "><a href="appendix/humorust.html">Appendix Z: HumorRust</a></li><li class="spacer"></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Guide to Rustc Development</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rustc-dev-guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rustc-dev-guide/edit/master/src/llvm-coverage-instrumentation.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="llvm-source-based-code-coverage"><a class="header" href="#llvm-source-based-code-coverage">LLVM Source-Based Code Coverage</a></h1>
<ul>
<li><a href="#rust-symbol-mangling">Rust symbol mangling</a></li>
<li><a href="#components-of-llvm-coverage-instrumentation-in-rustc">Components of LLVM Coverage Instrumentation in <code>rustc</code></a>
<ul>
<li><a href="#llvm-runtime-dependency">LLVM Runtime Dependency</a></li>
<li><a href="#mir-pass-instrumentcoverage">MIR Pass: <code>InstrumentCoverage</code></a></li>
<li><a href="#counter-injection-and-coverage-map-pre-staging">Counter Injection and Coverage Map Pre-staging</a></li>
<li><a href="#coverage-map-generation">Coverage Map Generation</a></li>
</ul>
</li>
<li><a href="#testing-llvm-coverage">Testing LLVM Coverage</a></li>
<li><a href="#implementation-details-of-the-instrumentcoverage-mir-pass">Implementation Details of the <code>InstrumentCoverage</code> MIR Pass</a>
<ul>
<li><a href="#the-coveragegraph">The <code>CoverageGraph</code></a></li>
<li><a href="#coveragespans"><code>CoverageSpans</code></a></li>
<li><a href="#make_bcb_counters"><code>make_bcb_counters()</code></a></li>
<li><a href="#injecting-counters-into-a-mir-basicblock">Injecting counters into a MIR <code>BasicBlock</code></a></li>
<li><a href="#additional-debugging-support">Additional Debugging Support</a></li>
</ul>
</li>
</ul>
<p><code>rustc</code> supports detailed source-based code and test coverage analysis
with a command line option (<code>-C instrument-coverage</code>) that instruments Rust
libraries and binaries with additional instructions and data, at compile time.</p>
<p>The coverage instrumentation injects calls to the LLVM intrinsic instruction
<a href="https://llvm.org/docs/LangRef.html#llvm-instrprof-increment-intrinsic"><code>llvm.instrprof.increment</code></a> at code branches
(based on a MIR-based control flow analysis), and LLVM converts these to
instructions that increment static counters, when executed. The LLVM coverage
instrumentation also requires a <a href="https://llvm.org/docs/CoverageMappingFormat.html">Coverage Map</a> that encodes source metadata,
mapping counter IDs--directly and indirectly--to the file locations (with
start and end line and column).</p>
<p>Rust libraries, with or without coverage instrumentation, can be linked into
instrumented binaries. When the program is executed and cleanly terminates,
LLVM libraries write the final counter values to a file (<code>default.profraw</code> or
a custom file set through environment variable <code>LLVM_PROFILE_FILE</code>).</p>
<p>Developers use existing LLVM coverage analysis tools to decode <code>.profraw</code>
files, with corresponding Coverage Maps (from matching binaries that produced
them), and generate various reports for analysis, for example:</p>
<p><img alt="Screenshot of sample `llvm-cov show` result, for function add_quoted_string"
 src="img/llvm-cov-show-01.png" class="center"/>
<br/></p>
<p>Detailed instructions and examples are documented in the
<a href="https://doc.rust-lang.org/nightly/rustc/instrument-coverage.html">Rustc Book</a>.</p>
<h2 id="rust-symbol-mangling"><a class="header" href="#rust-symbol-mangling">Rust symbol mangling</a></h2>
<p><code>-C instrument-coverage</code> automatically enables Rust symbol mangling <code>v0</code> (as
if the user specified <code>-C symbol-mangling-version=v0</code> option when invoking
<code>rustc</code>) to ensure consistent and reversible name mangling. This has two
important benefits:</p>
<ol>
<li>LLVM coverage tools can analyze coverage over multiple runs, including some
changes to source code; so mangled names must be consistent across compilations.</li>
<li>LLVM coverage reports can report coverage by function, and even separates
out the coverage counts of each unique instantiation of a generic function,
if invoked with multiple type substitution variations.</li>
</ol>
<h2 id="components-of-llvm-coverage-instrumentation-in-rustc"><a class="header" href="#components-of-llvm-coverage-instrumentation-in-rustc">Components of LLVM Coverage Instrumentation in <code>rustc</code></a></h2>
<h3 id="llvm-runtime-dependency"><a class="header" href="#llvm-runtime-dependency">LLVM Runtime Dependency</a></h3>
<p>Coverage data is only generated by running the executable Rust program. <code>rustc</code>
statically links coverage-instrumented binaries with LLVM runtime code
(<a href="https://github.com/llvm/llvm-project/tree/main/compiler-rt/lib/profile">compiler-rt</a>) that implements program hooks
(such as an <code>exit</code> hook) to write the counter values to the <code>.profraw</code> file.</p>
<p>In the <code>rustc</code> source tree, <code>library/profiler_builtins</code> bundles the LLVM
<code>compiler-rt</code> code into a Rust library crate. (When building <code>rustc</code>, the
<code>profiler_builtins</code> library is only included when <code>profiler = true</code> is set
in <code>rustc</code>'s <code>config.toml</code>.)</p>
<p>When compiling with <code>-C instrument-coverage</code>,
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_metadata/creader/struct.CrateLoader.html#method.postprocess"><code>CrateLoader::postprocess()</code></a> dynamically loads the
<code>profiler_builtins</code> library by calling <code>inject_profiler_runtime()</code>.</p>
<h3 id="mir-pass-instrumentcoverage"><a class="header" href="#mir-pass-instrumentcoverage">MIR Pass: <code>InstrumentCoverage</code></a></h3>
<p>Coverage instrumentation is performed on the MIR with a <a href="mir/passes.html">MIR pass</a>
called <a href="https://github.com/rust-lang/rust/tree/master/compiler/rustc_mir_transform/src/coverage"><code>InstrumentCoverage</code></a>. This MIR pass analyzes
the control flow graph (CFG)--represented by MIR <code>BasicBlock</code>s--to identify
code branches, and injects additional <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.StatementKind.html#variant.Coverage"><code>Coverage</code></a>
statements into the <code>BasicBlock</code>s.</p>
<p>A MIR <code>Coverage</code> statement is a virtual instruction that indicates a counter
should be incremented when its adjacent statements are executed, to count
a span of code (<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/coverage/struct.CodeRegion.html"><code>CodeRegion</code></a>). It counts the number of times a
branch is executed, and also specifies the exact location of that code span in
the Rust source code.</p>
<p>Note that many of these <code>Coverage</code> statements will <em>not</em> be converted into
physical counters (or any other executable instructions) in the final binary.
Some of them will be (see <code>CoverageKind::</code><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/coverage/enum.CoverageKind.html#variant.Counter"><code>Counter</code></a>),
but other counters can be computed on the fly, when generating a coverage
report, by mapping a <code>CodeRegion</code> to a
<code>CoverageKind</code>::<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/coverage/enum.CoverageKind.html#variant.Expression"><code>Expression</code></a>.</p>
<p>As an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_func(flag: bool) {
    // increment Counter(1)
    ...
    if flag {
        // increment Counter(2)
        ...
    } else {
        // count = Expression(1) = Counter(1) - Counter(2)
        ...
    }
    // count = Expression(2) = Counter(1) + Zero
    //     or, alternatively, Expression(2) = Counter(2) + Expression(1)
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>In this example, four contiguous code regions are counted while only
incrementing two counters.</p>
<p>CFG analysis is used to not only determine <em>where</em> the branches are, for
conditional expressions like <code>if</code>, <code>else</code>, <code>match</code>, and <code>loop</code>, but also to
determine where expressions can be used in place of physical counters.</p>
<p>The advantages of optimizing coverage through expressions are more pronounced
with loops. Loops generally include at least one conditional branch that
determines when to break out of a loop (a <code>while</code> condition, or an <code>if</code> or
<code>match</code> with a <code>break</code>). In MIR, this is typically lowered to a <code>SwitchInt</code>,
with one branch to stay in the loop, and another branch to break out of the
loop. The branch that breaks out will almost always execute less often,
so <code>InstrumentCoverage</code> chooses to add a <code>Counter</code> to that branch, and an
<code>Expression(continue) = Counter(loop) - Counter(break)</code> to the branch that
continues.</p>
<p>The <code>InstrumentCoverage</code> MIR pass is documented in
<a href="#implementation-details-of-the-instrumentcoverage-mir-pass">more detail below</a>.</p>
<h3 id="counter-injection-and-coverage-map-pre-staging"><a class="header" href="#counter-injection-and-coverage-map-pre-staging">Counter Injection and Coverage Map Pre-staging</a></h3>
<p>When the compiler enters <a href="backend/lowering-mir.html">the Codegen phase</a>, with a
coverage-enabled MIR, <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/mir/struct.FunctionCx.html#method.codegen_statement"><code>codegen_statement()</code></a> converts each
MIR <code>Statement</code> into some backend-specific action or instruction.
<code>codegen_statement()</code> forwards <code>Coverage</code> statements to
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/mir/struct.FunctionCx.html#method.codegen_coverage"><code>codegen_coverage()</code></a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn codegen_statement(&amp;mut self, mut bx: Bx, statement: &amp;mir::Statement&lt;'tcx&gt;) -&gt; Bx {
        ...
        match statement.kind {
            ...
            mir::StatementKind::Coverage(box ref coverage) =&gt; {
                self.codegen_coverage(&amp;mut bx, coverage.clone(), statement.source_info.scope);
                bx
            }
<span class="boring">}
</span></code></pre></pre>
<p><code>codegen_coverage()</code> handles each <code>CoverageKind</code> as follows:</p>
<ul>
<li>For all <code>CoverageKind</code>s, Coverage data (counter ID, expression equation
and ID, and code regions) are passed to the backend's <code>Builder</code>, to
populate data structures that will be used to generate the crate's
&quot;Coverage Map&quot;. (See the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/coverageinfo/map/struct.FunctionCoverage.html"><code>FunctionCoverage</code></a> <code>struct</code>.)</li>
<li>For <code>CoverageKind::Counter</code>s, an instruction is injected in the backend
IR to increment the physical counter, by calling the <code>BuilderMethod</code>
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/traits/trait.BuilderMethods.html#tymethod.instrprof_increment"><code>instrprof_increment()</code></a>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn codegen_coverage(&amp;self, bx: &amp;mut Bx, coverage: Coverage, scope: SourceScope) {
        ...
        let instance = ... // the scoped instance (current or inlined function)
        let Coverage { kind, code_region } = coverage;
        match kind {
            CoverageKind::Counter { function_source_hash, id } =&gt; {
                ...
                bx.add_coverage_counter(instance, id, code_region);
                ...
                bx.instrprof_increment(fn_name, hash, num_counters, index);
            }
            CoverageKind::Expression { id, lhs, op, rhs } =&gt; {
                bx.add_coverage_counter_expression(instance, id, lhs, op, rhs, code_region);
            }
            CoverageKind::Unreachable =&gt; {
                bx.add_coverage_unreachable(
                    instance,
                    code_region.expect(...
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>The function name <code>instrprof_increment()</code> is taken from the LLVM intrinsic
call of the same name (<a href="https://llvm.org/docs/LangRef.html#llvm-instrprof-increment-intrinsic"><code>llvm.instrprof.increment</code></a>),
and uses the same arguments and types; but note that, up to and through this
stage (even though modeled after LLVM's implementation for code coverage
instrumentation), the data and instructions are not strictly LLVM-specific.</p>
<p>But since LLVM is the only Rust-supported backend with the tooling to
process this form of coverage instrumentation, the backend for <code>Coverage</code>
statements is only implemented for LLVM, at this time.</p>
</blockquote>
<h3 id="coverage-map-generation"><a class="header" href="#coverage-map-generation">Coverage Map Generation</a></h3>
<p>With the instructions to increment counters now implemented in LLVM IR,
the last remaining step is to inject the LLVM IR variables that hold the
static data for the coverage map.</p>
<p><code>rustc_codegen_llvm</code>'s <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_llvm/base/fn.compile_codegen_unit.html"><code>compile_codegen_unit()</code></a> calls
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_llvm/context/struct.CodegenCx.html#method.coverageinfo_finalize"><code>coverageinfo_finalize()</code></a>,
which delegates its implementation to the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_llvm/coverageinfo/mapgen/fn.finalize.html"><code>rustc_codegen_llvm::coverageinfo::mapgen</code></a> module.</p>
<p>For each function <code>Instance</code> (code-generated from MIR, including multiple
instances of the same MIR for generic functions that have different type
substitution combinations), <code>mapgen</code>'s <code>finalize()</code> method queries the
<code>Instance</code>-associated <code>FunctionCoverage</code> for its <code>Counter</code>s, <code>Expression</code>s,
and <code>CodeRegion</code>s; and calls LLVM codegen APIs to generate
properly-configured variables in LLVM IR, according to very specific
details of the <a href="https://llvm.org/docs/CoverageMappingFormat.html"><em>LLVM Coverage Mapping Format</em></a>
(Version 6).<sup class="footnote-reference"><a href="#llvm-and-covmap-versions">1</a></sup></p>
<div class="footnote-definition" id="llvm-and-covmap-versions"><sup class="footnote-definition-label">1</sup>
<p>The Rust compiler (as of <!-- date-check: --> Jan 2023) supports <em>LLVM Coverage Mapping Format</em> 6.
It was introduced in <em>LLVM 13</em>, which is, as of <!-- date-check: Jan 2023 --> this writing,
the minimum supported LLVM version.
The Rust compiler will automatically use the most up-to-date coverage mapping format
version that is compatible with the compiler's built-in version of LLVM.</p>
</div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn finalize&lt;'ll, 'tcx&gt;(cx: &amp;CodegenCx&lt;'ll, 'tcx&gt;) {
    ...
    if !tcx.sess.instrument_coverage_except_unused_functions() {
        add_unused_functions(cx);
    }

    let mut function_coverage_map = match cx.coverage_context() {
        Some(ctx) =&gt; ctx.take_function_coverage_map(),
        None =&gt; return,
    };
    ...
    let mut mapgen = CoverageMapGenerator::new();

    for (instance, function_coverage) in function_coverage_map {
        ...
        let coverage_mapping_buffer = llvm::build_byte_buffer(|coverage_mapping_buffer| {
            mapgen.write_coverage_mapping(expressions, counter_regions, coverage_mapping_buffer);
        });
<span class="boring">}
</span></code></pre></pre>
<p><em>code snippet trimmed for brevity</em></p>
<p>One notable first step performed by <code>mapgen::finalize()</code> is the call to
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_llvm/coverageinfo/mapgen/fn.add_unused_functions.html"><code>add_unused_functions()</code></a>:</p>
<p>When finalizing the coverage map, <code>FunctionCoverage</code> only has the <code>CodeRegion</code>s
and counters for the functions that went through codegen; such as public
functions and &quot;used&quot; functions (functions referenced by other &quot;used&quot; or public
items). Any other functions (considered unused) were still parsed and processed
through the MIR stage.</p>
<p>The set of unused functions is computed via the set difference of all MIR
<code>DefId</code>s (<code>tcx</code> query <code>mir_keys</code>) minus the codegenned <code>DefId</code>s (<code>tcx</code> query
<code>codegened_and_inlined_items</code>). <code>add_unused_functions()</code> computes the set of
unused functions, queries the <code>tcx</code> for the previously-computed <code>CodeRegions</code>,
for each unused MIR, synthesizes an LLVM function (with no internal statements,
since it will not be called), and adds a new <code>FunctionCoverage</code>, with
<code>Unreachable</code> code regions.</p>
<h2 id="testing-llvm-coverage"><a class="header" href="#testing-llvm-coverage">Testing LLVM Coverage</a></h2>
<p>Coverage instrumentation in the MIR is validated by a <code>mir-opt</code> test:
<a href="https://github.com/rust-lang/rust/blob/master/tests/mir-opt/instrument_coverage.rs"><code>instrument-coverage</code></a>.</p>
<p>More complete testing of end-to-end coverage instrumentation and reports are
done in the <code>run-make-fulldeps</code> tests, with sample Rust programs (to be
instrumented) in the <a href="https://github.com/rust-lang/rust/tree/master/tests/run-make-fulldeps/coverage"><code>coverage</code></a> directory, and the
actual tests and expected results in <a href="https://github.com/rust-lang/rust/tree/master/tests/run-make-fulldeps/coverage-reports"><code>coverage-reports</code></a>.</p>
<p>Finally, the <a href="https://github.com/rust-lang/rust/tree/master/tests/run-make-fulldeps/coverage-llvmir"><code>coverage-llvmir</code></a> test compares compiles a simple Rust program
with <code>-C instrument-coverage</code> and compares the compiled program's LLVM IR to
expected LLVM IR instructions and structured data for a coverage-enabled
program, including various checks for Coverage Map-related metadata and the LLVM
intrinsic calls to increment the runtime counters.</p>
<p>Expected results for both the <code>mir-opt</code> tests and the <code>coverage*</code> tests under
<code>run-make-fulldeps</code> can be refreshed by running:</p>
<pre><code class="language-shell">$ ./x.py test mir-opt --bless
$ ./x.py test tests/run-make-fulldeps/coverage --bless
</code></pre>
<h2 id="implementation-details-of-the-instrumentcoverage-mir-pass"><a class="header" href="#implementation-details-of-the-instrumentcoverage-mir-pass">Implementation Details of the <code>InstrumentCoverage</code> MIR Pass</a></h2>
<p>The bulk of the implementation of the <code>InstrumentCoverage</code> MIR pass is performed
by the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/struct.Instrumentor.html"><code>Instrumentor</code></a>. For each MIR (each non-const, non-inlined
function, generic, or closure), the <code>Instrumentor</code>'s constructor prepares a
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/graph/struct.CoverageGraph.html"><code>CoverageGraph</code></a> and then executes
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/struct.Instrumentor.html#method.inject_counters"><code>inject_counters()</code></a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        Instrumentor::new(&amp;self.name(), tcx, mir_body).inject_counters();
<span class="boring">}
</span></code></pre></pre>
<p>The <code>CoverageGraph</code> is a coverage-specific simplification of the MIR control
flow graph (CFG). Its nodes are <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/graph/struct.BasicCoverageBlock.html"><code>BasicCoverageBlock</code>s</a>, which
encompass one or more sequentially-executed MIR <code>BasicBlock</code>s
(with no internal branching), plus a <code>CoverageKind</code> counter (to
be added, via coverage analysis), and an optional set of additional counters
to count incoming edges (if there are more than one).</p>
<p>The <code>Instrumentor</code>'s <code>inject_counters()</code> uses the <code>CoverageGraph</code> to
compute the best places to inject coverage counters, as MIR <code>Statement</code>s,
with the following steps:</p>
<ol>
<li>Depending on the debugging configurations in <code>rustc</code>'s, <code>config.toml</code>,
and <code>rustc</code> command line flags, various debugging features may be enabled
to enhance <code>debug!()</code> messages in logs, and to generate various &quot;dump&quot; files,
to help developers understand the MIR transformation process for coverage.
Most of the debugging features are implemented in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/debug"><code>debug</code></a>
sub-module.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/spans/struct.CoverageSpans.html#method.generate_coverage_spans"><code>generate_coverage_spans()</code></a> computes the minimum set of distinct,
non-branching code regions, from the MIR. These <code>CoverageSpan</code>s
represent a span of code that must be counted.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/counters/struct.BcbCounters.html#method.make_bcb_counters"><code>make_bcb_counters()</code></a> generates <code>CoverageKind::Counter</code>s and
<code>CoverageKind::Expression</code>s for each <code>CoverageSpan</code>, plus additional
<code>intermediate_expressions</code><sup class="footnote-reference"><a href="#intermediate-expressions">2</a></sup>, not associated with any <code>CodeRegion</code>, but
are required to compute a final <code>Expression</code> value for a <code>CodeRegion</code>.</li>
<li>Inject the new counters into the MIR, as new <code>StatementKind::Coverage</code>
statements. This is done by three distinct functions:
<ul>
<li><code>inject_coverage_span_counters()</code></li>
<li><code>inject_indirect_counters()</code></li>
<li><code>inject_intermediate_expression()</code>, called for each intermediate expression
returned from <code>make_bcb_counters()</code></li>
</ul>
</li>
</ol>
<div class="footnote-definition" id="intermediate-expressions"><sup class="footnote-definition-label">2</sup>
<p>Intermediate expressions are sometimes required
because <code>Expression</code>s are limited to binary additions or subtractions. For
example, <code>A + (B - C)</code> might represent an <code>Expression</code> count computed from three
other counters, <code>A</code>, <code>B</code>, and <code>C</code>, but computing that value requires an
intermediate expression for <code>B - C</code>.</p>
</div>
<h3 id="the-coveragegraph"><a class="header" href="#the-coveragegraph">The <code>CoverageGraph</code></a></h3>
<p>The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/graph/struct.CoverageGraph.html"><code>CoverageGraph</code></a> is derived from the MIR (<code>mir::Body</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let basic_coverage_blocks = CoverageGraph::from_mir(mir_body);
<span class="boring">}
</span></code></pre></pre>
<p>Like <code>mir::Body</code>, the <code>CoverageGraph</code> is also a
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/trait.DirectedGraph.html"><code>DirectedGraph</code></a>. Both graphs represent the function's
fundamental control flow, with many of the same
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/index.html#traits"><code>graph trait</code></a>s, supporting <code>start_node()</code>, <code>num_nodes()</code>,
<code>successors()</code>, <code>predecessors()</code>, and <code>is_dominated_by()</code>.</p>
<p>For anyone that knows how to work with the <a href="mir/index.html">MIR, as a CFG</a>, the
<code>CoverageGraph</code> will be familiar, and can be used in much the same way.
The nodes of the <code>CoverageGraph</code> are <code>BasicCoverageBlock</code>s (BCBs), which
index into an <code>IndexVec</code> of <code>BasicCoverageBlockData</code>. This is analogous
to the MIR CFG of <code>BasicBlock</code>s that index <code>BasicBlockData</code>.</p>
<p>Each <code>BasicCoverageBlockData</code> captures one or more MIR <code>BasicBlock</code>s,
exclusively, and represents the maximal-length sequence of <code>BasicBlocks</code>
without conditional branches.</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/graph/struct.CoverageGraph.html#method.compute_basic_coverage_blocks"><code>compute_basic_coverage_blocks()</code></a> builds the
<code>CoverageGraph</code> as a coverage-specific simplification of the MIR CFG. In
contrast with the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/simplify/struct.SimplifyCfg.html"><code>SimplifyCfg</code></a> MIR pass, this step does
not alter the MIR itself, because the <code>CoverageGraph</code> aggressively simplifies
the CFG, and ignores nodes that are not relevant to coverage. For example:</p>
<ul>
<li>The BCB CFG ignores (excludes) branches considered not relevant
to the current coverage solution. It excludes unwind-related code<sup class="footnote-reference"><a href="#78544">3</a></sup>
that is injected by the Rust compiler but has no physical source
code to count, which allows a <code>Call</code>-terminated BasicBlock
to be merged with its successor, within a single BCB.</li>
<li>A <code>Goto</code>-terminated <code>BasicBlock</code> can be merged with its successor
<strong><em>as long as</em></strong> it has the only incoming edge to the successor
<code>BasicBlock</code>.</li>
<li>Some BasicBlock terminators support Rust-specific concerns--like
borrow-checking--that are not relevant to coverage analysis. <code>FalseUnwind</code>,
for example, can be treated the same as a <code>Goto</code> (potentially merged with
its successor into the same BCB).</li>
</ul>
<div class="footnote-definition" id="78544"><sup class="footnote-definition-label">3</sup>
<p>(Note, however, that Issue <a href="https://github.com/rust-lang/rust/issues/78544">#78544</a> considers
providing future support for coverage of programs that intentionally
<code>panic</code>, as an option, with some non-trivial cost.)</p>
</div>
<p>The BCB CFG is critical to simplifying the coverage analysis by ensuring graph path-based
queries (<code>is_dominated_by()</code>, <code>predecessors</code>, <code>successors</code>, etc.) have branch (control flow)
significance.</p>
<p>To visualize the <code>CoverageGraph</code>, you can generate a <em>graphviz</em> <code>*.dot</code>
file with the following <code>rustc</code> flags:<sup class="footnote-reference"><a href="#graphviz-dark-mode">4</a></sup></p>
<div class="footnote-definition" id="graphviz-dark-mode"><sup class="footnote-definition-label">4</sup>
<p>This image also applies <code>-Z graphviz-dark-mode</code>, to
produce a Graphviz document with &quot;dark mode&quot; styling. If you use a dark mode or
theme in your development environment, you will probably want to use this
option so you can review the graphviz output without straining your vision.</p>
</div>
<pre><code class="language-shell">$ rustc -C instrument-coverage -Z dump-mir=InstrumentCoverage \
    -Z dump-mir-graphviz some_rust_source.rs
</code></pre>
<p>The <code>-Z dump-mir</code> flag requests <a href="mir/debugging.html">MIR debugging
output</a> (generating <code>*.mir</code> files, by default).
<code>-Z dump-mir-graphviz</code> additionally generates <code>*.dot</code> files.
<code>-Z dump-mir=InstrumentCoverage</code> restricts these files to the
<code>InstrumentCoverage</code> pass. All files are written to the <code>./mir_dump/</code>
directory, by default.</p>
<p>Files with names ending in <code>.-------.InstrumentCoverage.0.dot</code> contain the
<em>graphviz</em> representations of a <code>CoverageGraph</code> (one for each MIR, that is,
for each function and closure):</p>
<p><img alt="cropped image of a sample CoverageGraph in graphviz format"
 src="img/coverage-graphviz-01.png" style="border: 1px solid gray" class="center"/>
<br/></p>
<p>This image shows each <code>BasicCoverageBlock</code> as a rectangular <em>node</em>, with
directional edges (the arrows) leading from each node to its <code>successors()</code>.
The nodes contain information in sections:</p>
<ol>
<li>The gray header has a label showing the BCB ID (or <em>index</em> for looking up
its <code>BasicCoverageBlockData</code>).</li>
<li>The first content section shows the assigned <code>Counter</code> or <code>Expression</code> for
each contiguous section of code. (There may be more than one <code>Expression</code>
incremented by the same <code>Counter</code> for noncontiguous sections of code
representing the same sequential actions.) Note the code is represented by
the line and column ranges (for example: <code>52:28-52:33</code>, representing the
original source line 52, for columns 28-33). These are followed by the MIR
<code>Statement</code> or <code>Terminator</code> represented by that source range. (How these
coverage regions are determined is discussed in the following section.)</li>
<li>The final section(s) show the MIR <code>BasicBlock</code>s (by ID/index and its
<code>TerminatorKind</code>) contained in this BCB. The last BCB is separated out
because its <code>successors()</code> determine the edges leading out of the BCB, and
into the <code>leading_bb()</code> (first <code>BasicBlock</code>) of each successor BCB.</li>
</ol>
<p>Note, to find the <code>BasicCoverageBlock</code> from a final BCB <code>Terminator</code>'s
successor <code>BasicBlock</code>, there is an index and helper
function--<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/graph/struct.CoverageGraph.html#method.bcb_from_bb"><code>bcb_from_bb()</code></a>--to look up a <code>BasicCoverageBlock</code> from
<em>any</em> contained <code>BasicBlock</code>.</p>
<h3 id="coveragespans"><a class="header" href="#coveragespans"><code>CoverageSpans</code></a></h3>
<p>The <code>struct</code> <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/spans/struct.CoverageSpans.html"><code>CoverageSpans</code></a> builds and refines a final set of
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/spans/struct.CoverageSpan.html"><code>CoverageSpan</code></a>s, each representing the largest contiguous <code>Span</code>
of source within a single BCB. By definition--since each <code>Span</code> falls within a
BCB, the <code>Span</code> is also non-branching; so if any code in that <code>Span</code> has executed,
all code in the <code>Span</code> will have executed, the same number of times.</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/spans/struct.CoverageSpans.html#method.generate_coverage_spans"><code>CoverageSpans::generate_coverage_spans()</code></a> constructs
an initial set of <code>CoverageSpan</code>s from the <code>Span</code>s associated with each MIR
<code>Statement</code> and <code>Terminator</code>.</p>
<p>The final stage of <code>generate_coverage_spans()</code> is handled by
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/spans/struct.CoverageSpans.html#method.to_refined_spans"><code>to_refined_spans()</code></a>, which iterates through the <code>CoverageSpan</code>s,
merges and de-duplicates them, and returns an optimal, minimal set of <code>CoverageSpan</code>s
that can be used to assign coverage <code>Counter</code>s or <code>Expression</code>s, one-for-one.</p>
<p>An visual, interactive representation of the final <code>CoverageSpan</code>s can be
generated with the following <code>rustc</code> flags:</p>
<pre><code class="language-shell">$ rustc -C instrument-coverage -Z dump-mir=InstrumentCoverage \
    -Z dump-mir-spanview some_rust_source.rs
</code></pre>
<p>These flags request Spanview output for the <code>InstrumentCoverage</code> pass, and the
resulting files (one for each MIR, that is, for each function or closure) can be
found in the <code>mir_dump</code> directory (by default), with the extension:
<code>.-------.InstrumentCoverage.0.html</code>.</p>
<p><img alt="cropped image of a sample Spanview in a browser"
 src="img/coverage-spanview-01.png" style="border: 1px solid gray" class="center"/>
<br/></p>
<p>The image above shows one such example. The orange and blue backgrounds
highlight alternating <code>CoverageSpan</code>s from the refined set. Hovering over a
line expands the output on that line to show the MIR <code>BasicBlock</code> IDs covered
by each <code>CoverageSpan</code>. While hovering, the <code>CoverageSpan</code> under the pointer
also has a <em>tooltip</em> block of text, showing even more detail, including the
MIR <code>Statement</code>s and <code>Terminator</code>s contributing to the <code>CoverageSpan</code>, and
their individual <code>Span</code>s (which should be encapsulated within the code region
of the refined <code>CoverageSpan</code>)</p>
<h3 id="make_bcb_counters"><a class="header" href="#make_bcb_counters"><code>make_bcb_counters()</code></a></h3>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/counters/struct.BcbCounters.html#method.make_bcb_counters"><code>make_bcb_counters()</code></a> traverses the <code>CoverageGraph</code> and adds a
<code>Counter</code> or <code>Expression</code> to every BCB. It uses <em>Control Flow Analysis</em>
to determine where an <code>Expression</code> can be used in place of a <code>Counter</code>.
<code>Expressions</code> have no runtime overhead, so if a viable expression (adding or
subtracting two other counters or expressions) can compute the same result as
an embedded counter, an <code>Expression</code> is preferred.</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/graph/struct.TraverseCoverageGraphWithLoops.html"><code>TraverseCoverageGraphWithLoops</code></a>
provides a traversal order that ensures all <code>BasicCoverageBlock</code> nodes in a
loop are visited before visiting any node outside that loop. The traversal
state includes a <code>context_stack</code>, with the current loop's context information
(if in a loop), as well as context for nested loops.</p>
<p>Within loops, nodes with multiple outgoing edges (generally speaking, these
are BCBs terminated in a <code>SwitchInt</code>) can be optimized when at least one
branch exits the loop and at least one branch stays within the loop. (For an
<code>if</code> or <code>while</code>, there are only two branches, but a <code>match</code> may have more.)</p>
<p>A branch that does not exit the loop should be counted by <code>Expression</code>, if
possible. Note that some situations require assigning counters to BCBs before
they are visited by traversal, so the <code>counter_kind</code> (<code>CoverageKind</code> for
a <code>Counter</code> or <code>Expression</code>) may have already been assigned, in which case
one of the other branches should get the <code>Expression</code>.</p>
<p>For a node with more than two branches (such as for more than two
<code>match</code> patterns), only one branch can be optimized by <code>Expression</code>. All
others require a <code>Counter</code> (unless its BCB <code>counter_kind</code> was previously
assigned).</p>
<p>A branch expression is derived from the equation:</p>
<pre><code class="language-text">Counter(branching_node) = SUM(Counter(branches))
</code></pre>
<p>It's important to
be aware that the <code>branches</code> in this equation are the outgoing <em>edges</em>
from the <code>branching_node</code>, but a <code>branch</code>'s target node may have other
incoming edges. Given the following graph, for example, the count for
<code>B</code> is the sum of its two incoming edges:</p>
<p><img alt="Example graph with multiple incoming edges to a branch node"
 src="img/coverage-branch-counting-01.png" class="center" style="width: 25%">
<br/></p>
<p>In this situation, BCB node <code>B</code> may require an edge counter for its
&quot;edge from A&quot;, and that edge might be computed from an <code>Expression</code>,
<code>Counter(A) - Counter(C)</code>. But an expression for the BCB <em>node</em> <code>B</code>
would be the sum of all incoming edges:</p>
<pre><code class="language-text">Expression((Counter(A) - Counter(C)) + SUM(Counter(remaining_edges)))
</code></pre>
<p>Note that this is only one possible configuration. The actual choice
of <code>Counter</code> vs. <code>Expression</code> also depends on the order of counter
assignments, and whether a BCB or incoming edge counter already has
its <code>Counter</code> or <code>Expression</code>.</p>
<h3 id="injecting-counters-into-a-mir-basicblock"><a class="header" href="#injecting-counters-into-a-mir-basicblock">Injecting counters into a MIR <code>BasicBlock</code></a></h3>
<p>With the refined <code>CoverageSpan</code>s, and after all <code>Counter</code>s and <code>Expression</code>s are
created, the final step is to inject the <code>StatementKind::Coverage</code> statements
into the MIR. There are three distinct sources, handled by the following
functions:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/struct.Instrumentor.html#method.inject_coverage_span_counters"><code>inject_coverage_span_counters()</code></a> injects the
counter from each <code>CoverageSpan</code>'s BCB.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/struct.Instrumentor.html#method.inject_indirect_counters"><code>inject_indirect_counters()</code></a> injects counters
for any BCB not assigned to a <code>CoverageSpan</code>, and for all edge counters.
These counters don't have <code>CoverageSpan</code>s.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/fn.inject_intermediate_expression.html"><code>inject_intermediate_expression()</code></a> injects
the intermediate expressions returned from <code>make_bcb_counters()</code>. These
counters aren't associated with any BCB, edge, or <code>CoverageSpan</code>.</li>
</ul>
<p>These three functions inject the <code>Coverage</code> statements into the MIR.
<code>Counter</code>s and <code>Expression</code>s with <code>CoverageSpan</code>s add <code>Coverage</code> statements
to a corresponding <code>BasicBlock</code>, with a <code>CodeRegion</code> computed from the
refined <code>Span</code> and current <code>SourceMap</code>.</p>
<p>All other <code>Coverage</code> statements have a <code>CodeRegion</code> of <code>None</code>, but they
still must be injected because they contribute to other <code>Expression</code>s.</p>
<p>Finally, edge's with a <code>CoverageKind::Counter</code> require a new <code>BasicBlock</code>,
so the counter is only incremented when traversing the branch edge.</p>
<h3 id="additional-debugging-support"><a class="header" href="#additional-debugging-support">Additional Debugging Support</a></h3>
<p>See the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/debug/index.html">crate documentation for <code>rustc_mir::transform::coverage::debug</code></a>
for a detailed description of the debug output, logging, and configuration options
available to developers working on the <code>InstrumentCoverage</code> pass.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="profile-guided-optimization.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="sanitizers.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="profile-guided-optimization.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="sanitizers.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>


    </body>
</html>
